# üß™ Testing en Plone 6 - Reglas y Buenas Pr√°cticas

## üì¶ Estructura de Tests

```
src/my.package/
‚îî‚îÄ‚îÄ src/my/package/
    ‚îú‚îÄ‚îÄ tests/
    ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ   ‚îú‚îÄ‚îÄ base.py                    # Layers y fixtures
    ‚îÇ   ‚îú‚îÄ‚îÄ conftest.py                # Configuraci√≥n pytest (opcional)
    ‚îÇ   ‚îú‚îÄ‚îÄ unit/                      # Tests unitarios / Unit tests
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_utils.py
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test_validators.py
    ‚îÇ   ‚îú‚îÄ‚îÄ integration/               # Tests de integraci√≥n / Integration tests
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_content_types.py
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_behaviors.py
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test_vocabularies.py
    ‚îÇ   ‚îî‚îÄ‚îÄ functional/                # Tests funcionales / Functional tests
    ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ       ‚îú‚îÄ‚îÄ test_views.py
    ‚îÇ       ‚îú‚îÄ‚îÄ test_workflows.py
    ‚îÇ       ‚îî‚îÄ‚îÄ test_permissions.py
    ‚îî‚îÄ‚îÄ testing.py                     # Definici√≥n de layers / Layers definition
```

## üöÄ Referencia R√°pida

| Tipo de Test | Layer | Velocidad | Cu√°ndo usar |
|-------------|-------|-----------|-------------|
| **Unitario** | Ninguno | ‚ö° Muy r√°pido | Funciones puras, validadores, utils |
| **Integraci√≥n** | `INTEGRATION_TESTING` | üê¢ Medio | Content types, behaviors, catalog |
| **Funcional** | `FUNCTIONAL_TESTING` | üêå Lento | Vistas, formularios, requests HTTP |
| **Permisos** | `INTEGRATION_TESTING` | üê¢ Medio | Roles, seguridad, Unauthorized |
| **Workflow** | `INTEGRATION_TESTING` | üê¢ Medio | Transiciones, estados |

### Comandos √∫tiles

```bash
# Ejecutar todos los tests
./bin/test -s my.package

# Solo tests de un archivo
./bin/test -s my.package -t test_content_types

# Solo tests unitarios
./bin/test -s my.package.tests.unit

# Solo tests de integraci√≥n
./bin/test -s my.package.tests.integration

# Con coverage
./bin/test -s my.package --coverage

# Coverage con HTML
./bin/test -s my.package --coverage --coverage-dir=htmlcov

# Verbose (detallado)
./bin/test -s my.package -vvv

# Con debugger en errores
./bin/test -s my.package -D

# Con ipdb
./bin/test -s my.package --ipdb
```

## üèóÔ∏è Testing Layers (Capas)

### Definici√≥n en testing.py
```python
from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FIXTURE
from plone.app.robotframework.testing import REMOTE_LIBRARY_BUNDLE_FIXTURE
from plone.app.testing import (
    FunctionalTesting,
    IntegrationTesting,
    PloneSandboxLayer,
    applyProfile,
)
from plone.testing import z2
import my.package


class MyPackageLayer(PloneSandboxLayer):
    """Layer base para my.package"""

    defaultBases = (PLONE_APP_CONTENTTYPES_FIXTURE,)

    def setUpZope(self, app, configurationContext):
        """Configurar productos Zope"""
        # Load ZCML
        self.loadZCML(package=my.package)

    def setUpPloneSite(self, portal):
        """Configurar sitio Plone"""
        # Instalar productos
        applyProfile(portal, 'my.package:default')


# Fixtures
MY_PACKAGE_FIXTURE = MyPackageLayer()

MY_PACKAGE_INTEGRATION_TESTING = IntegrationTesting(
    bases=(MY_PACKAGE_FIXTURE,),
    name='MyPackageLayer:IntegrationTesting',
)

MY_PACKAGE_FUNCTIONAL_TESTING = FunctionalTesting(
    bases=(MY_PACKAGE_FIXTURE,),
    name='MyPackageLayer:FunctionalTesting',
)

MY_PACKAGE_ACCEPTANCE_TESTING = FunctionalTesting(
    bases=(
        MY_PACKAGE_FIXTURE,
        REMOTE_LIBRARY_BUNDLE_FIXTURE,
        z2.ZSERVER_FIXTURE,
    ),
    name='MyPackageLayer:AcceptanceTesting',
)
```

## üß™ Tests Unitarios

### Caracter√≠sticas
- No requieren Plone site
- R√°pidos y aislados
- Testean funciones y clases puras
- Sin acceso a portal, catalog, etc.

### Ejemplo
```python
import unittest
from my.package.utils import normalize_data


class TestUtils(unittest.TestCase):
    """Tests unitarios para utilidades"""

    def test_normalize_data_empty(self):
        """Test normalizaci√≥n de datos vac√≠os"""
        result = normalize_data({})
        self.assertEqual(result, {})

    def test_normalize_data_with_values(self):
        """Test normalizaci√≥n con valores"""
        data = {'key': 'value', 'nested': {'inner': 'data'}}
        result = normalize_data(data)
        self.assertIsInstance(result, dict)
        self.assertEqual(result['key'], 'value')

    def test_normalize_data_invalid(self):
        """Test normalizaci√≥n con datos inv√°lidos"""
        with self.assertRaises(TypeError):
            normalize_data(None)
```

## üîó Tests de Integraci√≥n

### Caracter√≠sticas
- Requieren layer con Plone site
- Acceso a portal, catalog, tipos de contenido
- Sin transacciones HTTP
- M√°s lentos que unitarios

### Ejemplo: Content Type
```python
import unittest
from plone import api
from plone.app.testing import setRoles, TEST_USER_ID
from my.package.testing import MY_PACKAGE_INTEGRATION_TESTING


class TestMyContentType(unittest.TestCase):
    """Tests de integraci√≥n para tipo de contenido personalizado"""

    layer = MY_PACKAGE_INTEGRATION_TESTING

    def setUp(self):
        """Configuraci√≥n inicial"""
        self.portal = self.layer['portal']
        self.request = self.layer['request']
        setRoles(self.portal, TEST_USER_ID, ['Manager'])

    def test_content_type_creation(self):
        """Test creaci√≥n de tipo de contenido"""
        content = api.content.create(
            container=self.portal,
            type='MyContentType',
            id='mycontent1',
            title='Test Content',
        )
        self.assertEqual(content.portal_type, 'MyContentType')
        self.assertEqual(content.title, 'Test Content')

    def test_content_type_fields(self):
        """Test campos del tipo de contenido"""
        content = api.content.create(
            container=self.portal,
            type='MyContentType',
            id='mycontent1',
            title='Test Content',
        )
        # Verificar campos espec√≠ficos
        self.assertTrue(hasattr(content, 'custom_field'))

    def test_content_type_in_catalog(self):
        """Test indexaci√≥n en cat√°logo"""
        content = api.content.create(
            container=self.portal,
            type='MyContentType',
            id='mycontent1',
            title='Test Content',
        )
        results = api.content.find(portal_type='MyContentType')
        self.assertEqual(len(results), 1)
        self.assertEqual(results[0].Title, 'Test Content')
```

### Ejemplo: Behavior
```python
import unittest
from plone import api
from plone.app.testing import setRoles, TEST_USER_ID
from my.package.testing import MY_PACKAGE_INTEGRATION_TESTING
from my.package.behaviors import IMyBehavior


class TestMyBehavior(unittest.TestCase):
    """Tests para behavior personalizado"""

    layer = MY_PACKAGE_INTEGRATION_TESTING

    def setUp(self):
        """Configuraci√≥n inicial"""
        self.portal = self.layer['portal']
        setRoles(self.portal, TEST_USER_ID, ['Manager'])

    def test_behavior_available(self):
        """Test que behavior est√° disponible"""
        content = api.content.create(
            container=self.portal,
            type='Document',
            id='doc1',
        )
        behavior = IMyBehavior(content)
        self.assertIsNotNone(behavior)

    def test_behavior_fields(self):
        """Test campos del behavior"""
        content = api.content.create(
            container=self.portal,
            type='Document',
            id='doc1',
        )
        behavior = IMyBehavior(content)
        self.assertTrue(hasattr(behavior, 'custom_attribute'))
```

## ‚öôÔ∏è Tests Funcionales

### Caracter√≠sticas
- Requieren layer funcional
- Simulan requests HTTP
- Testing de vistas y formularios
- M√°s lentos, m√°s completos

### Ejemplo: Vista
```python
import unittest
from plone import api
from plone.app.testing import (
    setRoles,
    TEST_USER_ID,
    TEST_USER_NAME,
    TEST_USER_PASSWORD,
)
from plone.testing.z2 import Browser
from my.package.testing import MY_PACKAGE_FUNCTIONAL_TESTING


class TestMyView(unittest.TestCase):
    """Tests funcionales para vista personalizada"""

    layer = MY_PACKAGE_FUNCTIONAL_TESTING

    def setUp(self):
        """Configuraci√≥n inicial"""
        self.portal = self.layer['portal']
        self.request = self.layer['request']
        setRoles(self.portal, TEST_USER_ID, ['Manager'])

        # Crear contenido de test
        self.content = api.content.create(
            container=self.portal,
            type='Document',
            id='doc1',
            title='Test Document',
        )

        # Browser
        self.browser = Browser(self.layer['app'])
        self.browser.handleErrors = False

    def test_view_renders(self):
        """Test renderizado de vista"""
        self.browser.open(self.content.absolute_url())
        self.assertIn('Test Document', self.browser.contents)

    def test_view_authenticated(self):
        """Test vista con usuario autenticado"""
        self.browser.addHeader(
            'Authorization',
            f'Basic {TEST_USER_NAME}:{TEST_USER_PASSWORD}'
        )
        self.browser.open(self.content.absolute_url())
        self.assertEqual(self.browser.status, 200)

    def test_edit_form(self):
        """Test formulario de edici√≥n"""
        self.browser.addHeader(
            'Authorization',
            f'Basic {TEST_USER_NAME}:{TEST_USER_PASSWORD}'
        )
        self.browser.open(f'{self.content.absolute_url()}/edit')
        self.assertIn('form', self.browser.contents)
```

## üéØ Tests Funcionales Avanzados: Lecciones Aprendidas

### ‚ö†Ô∏è IMPORTANTE: No usar TestRequest en Tests Funcionales

**‚ùå NO HACER**:
```python
from plone.testing.z2 import TestRequest

def test_my_view(self):
    request = TestRequest()  # ‚ùå NO FUNCIONA en tests funcionales
```

**‚úÖ HACER**:
```python
def setUp(self):
    """Configuraci√≥n inicial"""
    self.portal = self.layer['portal']
    self.app = self.layer['app']
    self.request = self.layer['request']  # ‚úÖ Usar request del layer
```

### üìù Prints Informativos para Seguimiento

Los tests funcionales complejos deben incluir prints informativos para facilitar el seguimiento:

```python
import unittest
import warnings
from plone import api
from plone.app.testing import setRoles, TEST_USER_ID, TEST_USER_NAME, login, logout
from AccessControl import Unauthorized
from my.package.testing import MY_PACKAGE_FUNCTIONAL_TESTING


class TestComplexPermissions(unittest.TestCase):
    """Tests funcionales con prints informativos"""

    layer = MY_PACKAGE_FUNCTIONAL_TESTING

    def setUp(self):
        # Suprimir warnings molestos
        warnings.filterwarnings("ignore", category=ResourceWarning,
                                message=".*unclosed file.*")
        warnings.filterwarnings("ignore", category=DeprecationWarning)

        self.app = self.layer['app']
        self.portal = self.layer['portal']
        self.request = self.layer['request']  # ‚úÖ Request del layer

        # Setup inicial...
        logout()

    def test_permissions_as_secretari(self):
        """Test permisos de OG1-Secretari"""
        print("\n‚úÖ Verificando permisos del rol OG1-Secretari")

        logout()
        setRoles(self.portal, TEST_USER_ID, ['OG1-Secretari'])
        login(self.portal, TEST_USER_NAME)

        # Test estado PLANIFICADA
        print("  ‚úì Verificando acceso en sesi√≥n PLANIFICADA")
        self.assertTrue(self.content.restrictedTraverse('view')())
        print("  ‚úì Acceso correcto a sesi√≥n PLANIFICADA")

        # Test estado CONVOCADA
        print("  ‚úì Verificando acceso en sesi√≥n CONVOCADA")
        self.assertTrue(self.content2.restrictedTraverse('view')())
        print("  ‚úì Acceso correcto a sesi√≥n CONVOCADA")

        print("  ‚úì Verificaci√≥n completa como OG1-Secretari")
        logout()

    def test_permissions_as_membre(self):
        """Test restricciones de OG3-Membre"""
        print("\n‚ùå Verificando restricciones del rol OG3-Membre")

        logout()
        setRoles(self.portal, TEST_USER_ID, ['OG3-Membre'])
        login(self.portal, TEST_USER_NAME)

        # Test restricci√≥n en PLANIFICADA
        print("  ‚úì Verificando restricciones en sesi√≥n PLANIFICADA")
        with self.assertRaises(Unauthorized):
            self.content.restrictedTraverse('view')()
        print("  ‚úì Acceso denegado correctamente en sesi√≥n PLANIFICADA")

        # Test acceso permitido en CONVOCADA
        print("  ‚úì Verificando acceso permitido en sesi√≥n CONVOCADA")
        self.assertTrue(self.content2.restrictedTraverse('view')())
        print("  ‚úì Acceso permitido en sesi√≥n CONVOCADA")

        print("  ‚úì Verificaci√≥n completa como OG3-Membre")
        logout()
```

### üé® Convenciones de Prints Informativos

#### Emojis para mejor visibilidad
```python
# Inicio de test con acceso permitido
print("\n‚úÖ Verificando permisos del rol X")

# Inicio de test con restricciones
print("\n‚ùå Verificando restricciones del rol Y")

# Pasos intermedios exitosos
print("  ‚úì Acceso correcto a...")
print("  ‚úì Verificaci√≥n completa como...")

# Restricciones aplicadas correctamente
print("  ‚úì Acceso denegado correctamente en...")
print("  ‚úì Restricciones aplicadas correctamente en...")
```

#### Estructura de prints
```python
# 1. Print de inicio de test (nivel principal)
print("\n‚úÖ Verificando permisos del rol OG1-Secretari en √≥rgano membres")

# 2. Print de contexto adicional si hay combinaciones de roles
print("  ‚úì Verificando permisos como OG1-Secretari (con OG2-Editor)")

# 3. Prints de progreso por secci√≥n
print("  ‚úì Acceso correcto a archivos en sesi√≥n PLANIFICADA")
print("  ‚úì Acceso correcto a archivos en sesi√≥n CONVOCADA")

# 4. Print de finalizaci√≥n
print("  ‚úì Verificaci√≥n completa como OG1-Secretari")
```

### üì¶ Template Completo de Test Funcional con Prints

```python
import unittest
import warnings
from AccessControl import Unauthorized
from plone import api
from plone.app.testing import (
    TEST_USER_ID,
    TEST_USER_NAME,
    login,
    logout,
    setRoles,
)
from zope.component import getMultiAdapter
from Products.CMFPlone.interfaces import ISelectableConstrainTypes

from my.package.testing import MY_PACKAGE_FUNCTIONAL_TESTING
from my.package.browser.views import DisplayFile, Download
from zope.publisher.interfaces import NotFound


class FunctionalTestCase(unittest.TestCase):
    """Tests funcionales con prints informativos (Plone 6)."""

    layer = MY_PACKAGE_FUNCTIONAL_TESTING

    def setUp(self):
        """Configuraci√≥n inicial del test."""
        # Suprimir warnings molestos
        warnings.filterwarnings("ignore", category=ResourceWarning,
                                message=".*unclosed file.*")
        warnings.filterwarnings("ignore", category=DeprecationWarning)

        # Referencias del layer
        self.app = self.layer['app']
        self.portal = self.layer['portal']
        self.request = self.layer['request']  # ‚úÖ Request del layer

        # Setup de estructura de contenido
        # ... crear contenido necesario ...

        logout()

    def should_view_as_role_x(self, root_path, roles_info=""):
        """Helper para verificar permisos de un rol espec√≠fico."""
        if roles_info:
            print(f"  ‚úì Verificando permisos como RoleX ({roles_info})")
        else:
            print("  ‚úì Verificando permisos como RoleX")

        request = self.request  # ‚úÖ Usar request del layer

        # Verificar acceso a contenido
        self.assertTrue(root_path.item.restrictedTraverse('view')())

        # Verificar acceso a archivos
        self.assertTrue(
            DisplayFile(root_path.item.file, request)
            .publishTraverse(request, 'visiblefile')()
        )

        print("  ‚úì Acceso correcto en estado X")
        print("  ‚úì Verificaci√≥n completa como RoleX")

    def should_not_view_as_role_y(self, root_path, roles_info=""):
        """Helper para verificar restricciones de un rol espec√≠fico."""
        if roles_info:
            print(f"  ‚úì Verificando restricciones como RoleY ({roles_info})")
        else:
            print("  ‚úì Verificando restricciones como RoleY")

        request = self.request  # ‚úÖ Usar request del layer

        # Verificar que el acceso est√° denegado
        with self.assertRaises(Unauthorized):
            root_path.item.restrictedTraverse('view')()

        # Verificar que archivos est√°n protegidos
        with self.assertRaises(NotFound):
            DisplayFile(root_path.item.file, request)
            .publishTraverse(request, 'visiblefile')()

        print("  ‚úì Acceso denegado correctamente en estado X")
        print("  ‚úì Verificaci√≥n completa como RoleY")

    def test_permissions_role_x(self):
        """Test permisos de RoleX."""
        print("\n‚úÖ Verificando permisos del rol RoleX")

        logout()
        root_path = self.portal.ca.testingfolder

        # Test con RoleX solo
        setRoles(self.portal, TEST_USER_ID, ['RoleX'])
        login(self.portal, TEST_USER_NAME)
        self.should_view_as_role_x(root_path, "solo")
        logout()

        # Test con RoleX + RoleY
        setRoles(self.portal, TEST_USER_ID, ['RoleX', 'RoleY'])
        login(self.portal, TEST_USER_NAME)
        self.should_view_as_role_x(root_path, "con RoleY")
        logout()

    def test_permissions_role_y(self):
        """Test restricciones de RoleY."""
        print("\n‚ùå Verificando restricciones del rol RoleY")

        logout()
        root_path = self.portal.ca.testingfolder

        setRoles(self.portal, TEST_USER_ID, ['RoleY'])
        login(self.portal, TEST_USER_NAME)
        self.should_not_view_as_role_y(root_path, "solo")
        logout()
```

### üîë Puntos Clave

1. **‚úÖ Siempre usar `self.request` del layer**, nunca crear `TestRequest()`
2. **‚úÖ A√±adir prints informativos** con emojis para seguimiento visual
3. **‚úÖ Organizar prints por niveles** (principal ‚Üí contexto ‚Üí progreso ‚Üí finalizaci√≥n)
4. **‚úÖ Suprimir warnings** con `warnings.filterwarnings` en `setUp`
5. **‚úÖ Usar helpers reutilizables** para verificar permisos de cada rol
6. **‚úÖ Incluir contexto en prints** cuando se prueban combinaciones de roles
7. **‚úÖ Tests independientes** con `logout()` entre tests

### ‚ùå Errores Comunes a Evitar

```python
# ‚ùå NO: Crear TestRequest manualmente
from plone.testing.z2 import TestRequest
request = TestRequest()

# ‚úÖ S√ç: Usar request del layer
request = self.request

# ‚ùå NO: Tests sin prints informativos
def test_permissions(self):
    self.assertTrue(...)

# ‚úÖ S√ç: Tests con prints descriptivos
def test_permissions(self):
    print("\n‚úÖ Verificando permisos del rol X")
    self.assertTrue(...)
    print("  ‚úì Verificaci√≥n completa")

# ‚ùå NO: Olvidar suprimir warnings
def setUp(self):
    self.portal = self.layer['portal']

# ‚úÖ S√ç: Suprimir warnings molestos
def setUp(self):
    warnings.filterwarnings("ignore", category=ResourceWarning)
    warnings.filterwarnings("ignore", category=DeprecationWarning)
    self.portal = self.layer['portal']

# ‚ùå NO: No hacer logout entre tests
def test_role_a(self):
    setRoles(self.portal, TEST_USER_ID, ['RoleA'])
    login(self.portal, TEST_USER_NAME)
    # test...

def test_role_b(self):  # ‚ùå Hereda estado del test anterior
    setRoles(self.portal, TEST_USER_ID, ['RoleB'])

# ‚úÖ S√ç: Logout al inicio y final de cada test
def test_role_a(self):
    logout()
    setRoles(self.portal, TEST_USER_ID, ['RoleA'])
    login(self.portal, TEST_USER_NAME)
    # test...
    logout()

def test_role_b(self):
    logout()
    setRoles(self.portal, TEST_USER_ID, ['RoleB'])
    login(self.portal, TEST_USER_NAME)
    # test...
    logout()
```

## üîê Tests de Permisos

### Ejemplo
```python
import unittest
from AccessControl import Unauthorized
from plone import api
from plone.app.testing import (
    login,
    logout,
    setRoles,
    TEST_USER_ID,
    TEST_USER_NAME,
)
from my.package.testing import MY_PACKAGE_INTEGRATION_TESTING


class TestPermissions(unittest.TestCase):
    """Tests de permisos"""

    layer = MY_PACKAGE_INTEGRATION_TESTING

    def setUp(self):
        """Configuraci√≥n inicial"""
        self.portal = self.layer['portal']
        setRoles(self.portal, TEST_USER_ID, ['Manager'])

        self.content = api.content.create(
            container=self.portal,
            type='Document',
            id='doc1',
            title='Test Document',
        )

    def test_anonymous_cannot_add(self):
        """Test que an√≥nimo no puede a√±adir"""
        logout()
        with self.assertRaises(Unauthorized):
            api.content.create(
                container=self.portal,
                type='Document',
                id='doc2',
            )

    def test_member_can_view(self):
        """Test que miembro puede ver"""
        setRoles(self.portal, TEST_USER_ID, ['Member'])
        login(self.portal, TEST_USER_NAME)

        # Verificar que puede acceder
        self.assertTrue(
            api.user.has_permission(
                'View',
                obj=self.content,
            )
        )

    def test_manager_can_edit(self):
        """Test que manager puede editar"""
        setRoles(self.portal, TEST_USER_ID, ['Manager'])

        # Verificar que puede modificar
        self.assertTrue(
            api.user.has_permission(
                'Modify portal content',
                obj=self.content,
            )
        )
```

## üîÑ Tests de Workflow

### Ejemplo
```python
import unittest
from plone import api
from plone.app.testing import setRoles, TEST_USER_ID
from my.package.testing import MY_PACKAGE_INTEGRATION_TESTING


class TestWorkflow(unittest.TestCase):
    """Tests de workflow"""

    layer = MY_PACKAGE_INTEGRATION_TESTING

    def setUp(self):
        """Configuraci√≥n inicial"""
        self.portal = self.layer['portal']
        setRoles(self.portal, TEST_USER_ID, ['Manager'])

        self.content = api.content.create(
            container=self.portal,
            type='Document',
            id='doc1',
            title='Test Document',
        )

    def test_initial_state(self):
        """Test estado inicial"""
        state = api.content.get_state(self.content)
        self.assertEqual(state, 'private')

    def test_publish_transition(self):
        """Test transici√≥n a publicado"""
        api.content.transition(self.content, 'publish')
        state = api.content.get_state(self.content)
        self.assertEqual(state, 'published')

    def test_workflow_history(self):
        """Test historial de workflow"""
        api.content.transition(self.content, 'publish')

        workflow_history = self.portal.portal_workflow.getHistoryOf(
            'simple_publication_workflow',
            self.content
        )

        self.assertGreater(len(workflow_history), 0)
        self.assertEqual(workflow_history[-1]['action'], 'publish')

    def test_custom_transition(self):
        """Test transici√≥n personalizada"""
        # Si tienes workflow custom
        api.content.transition(self.content, 'my_custom_transition')
        state = api.content.get_state(self.content)
        self.assertEqual(state, 'my_custom_state')
```

## üé≠ Mocking y Patching

### Ejemplo con unittest.mock
```python
import unittest
from unittest.mock import Mock, patch, MagicMock
from my.package.testing import MY_PACKAGE_INTEGRATION_TESTING


class TestWithMocking(unittest.TestCase):
    """Tests con mocking"""

    layer = MY_PACKAGE_INTEGRATION_TESTING

    def setUp(self):
        """Configuraci√≥n inicial"""
        self.portal = self.layer['portal']

    @patch('my.package.utils.get_external_data')
    def test_external_api_call(self, mock_get):
        """Test llamada a API externa"""
        # Configurar mock
        mock_get.return_value = {'status': 'ok', 'data': [1, 2, 3]}

        # Ejecutar c√≥digo que usa la funci√≥n
        from my.package.utils import process_external_data
        result = process_external_data()

        # Verificar
        mock_get.assert_called_once()
        self.assertEqual(result['status'], 'ok')

    def test_catalog_query_mock(self):
        """Test query de cat√°logo con mock"""
        mock_catalog = Mock()
        mock_catalog.return_value = [
            Mock(Title='Item 1'),
            Mock(Title='Item 2'),
        ]

        # Usar mock
        results = mock_catalog()
        self.assertEqual(len(results), 2)

    @patch('my.package.views.send_email')
    def test_email_notification(self, mock_send):
        """Test env√≠o de email mockeado"""
        from my.package.views import notify_users

        notify_users(['user@example.com'])

        mock_send.assert_called_once_with(['user@example.com'])
```

## üìä Tests de √çndices y Metadatos

### Ejemplo
```python
import unittest
from plone import api
from plone.app.testing import setRoles, TEST_USER_ID
from my.package.testing import MY_PACKAGE_INTEGRATION_TESTING


class TestCatalogIndexes(unittest.TestCase):
    """Tests para √≠ndices de cat√°logo"""

    layer = MY_PACKAGE_INTEGRATION_TESTING

    def setUp(self):
        """Configuraci√≥n inicial"""
        self.portal = self.layer['portal']
        self.catalog = self.portal.portal_catalog
        setRoles(self.portal, TEST_USER_ID, ['Manager'])

    def test_custom_index_exists(self):
        """Test que √≠ndice personalizado existe"""
        indexes = self.catalog.indexes()
        self.assertIn('my_custom_index', indexes)

    def test_custom_metadata_exists(self):
        """Test que metadata personalizado existe"""
        metadata = self.catalog.schema()
        self.assertIn('my_custom_metadata', metadata)

    def test_index_content(self):
        """Test indexaci√≥n de contenido"""
        content = api.content.create(
            container=self.portal,
            type='Document',
            id='doc1',
            title='Test Document',
        )

        # Buscar usando √≠ndice custom
        results = self.catalog(my_custom_index='value')
        self.assertEqual(len(results), 1)
```

## üöÄ Comandos de Test

### Ejecutar Tests
```bash
# Todos los tests
bin/test -s my.package

# Tests espec√≠ficos
bin/test -s my.package -t test_content_type

# Tests de un m√≥dulo
bin/test -s my.package -m test_permissions

# Con verbosidad
bin/test -s my.package -v

# Solo unitarios
bin/test -s my.package.tests.unit

# Solo integraci√≥n
bin/test -s my.package.tests.integration

# Solo funcionales
bin/test -s my.package.tests.functional

# Coverage
bin/test -s my.package --coverage

# Coverage con reporte HTML
bin/test -s my.package --coverage --coverage-dir=htmlcov
```

## üìã Buenas Pr√°cticas

### ‚úÖ DO
- Usar layers apropiados (unit vs integration vs functional)
- Tests independientes y aislados
- setUp y tearDown limpios
- Nombres descriptivos: `test_content_creation_with_valid_data`
- Un assert por test (cuando sea posible)
- Testear casos edge y errores
- Usar factories para crear contenido
- Mock llamadas externas (APIs, filesystem, email)
- Tests r√°pidos (< 1s unitarios, < 5s integraci√≥n)
- Documentar qu√© se testea en docstring
- Limpiar datos en tearDown

### ‚ùå DON'T
- Tests que dependen del orden de ejecuci√≥n
- Tests que modifican estado global
- Tests con sleeps o timeouts
- Tests que requieren internet
- Tests sin asserts
- Tests que testean implementaci√≥n en lugar de comportamiento
- Duplicar l√≥gica de negocio en tests
- Tests gigantes que testean m√∫ltiples cosas
- Hardcodear IDs o paths absolutos

## üîß Fixtures y Helpers

### base.py
```python
from plone import api
from plone.app.testing import setRoles, TEST_USER_ID


class BaseTestCase:
    """Clase base para tests con helpers comunes"""

    def create_content(self, portal_type='Document', **kwargs):
        """Helper gen√©rico para crear contenido"""
        defaults = {
            'container': self.portal,
            'type': portal_type,
            'id': f'test-{portal_type.lower()}',
            'title': f'Test {portal_type}',
        }
        defaults.update(kwargs)
        return api.content.create(**defaults)

    def grant_permission(self, permission, user=TEST_USER_ID, roles=['Manager']):
        """Helper para otorgar permisos"""
        setRoles(self.portal, user, roles)

    def create_member(self, username='testmember', email='test@example.com'):
        """Helper para crear usuario"""
        return api.user.create(
            email=email,
            username=username,
            password='secret123',
        )

    def login_as(self, username):
        """Helper para login como usuario"""
        from plone.app.testing import login
        login(self.portal, username)
```

## üìä Coverage

### Configuraci√≥n .coveragerc

#### Para paquete en buildout (src/my.package/.coveragerc)
```ini
[run]
source = src/my/package

[report]
include =
    src/my/package/*

omit =
    */test*
    */tests/*
    */testing/*

[html]
directory = coverage_report

precision = 2
exclude_lines =
    pragma: no cover
    def __repr__
    raise AssertionError
    raise NotImplementedError
    if __name__ == .__main__.:
    if TYPE_CHECKING:
    @abstractmethod
```

#### ‚ö†Ô∏è IMPORTANTE: Path Configuration

El `source` debe ser relativo al directorio donde reside el `.coveragerc`:

```ini
# ‚úÖ CORRECTO: Si .coveragerc est√° en src/genweb.organs/
[run]
source = src/genweb/organs

# ‚ùå INCORRECTO: Path absoluto o incorrecto
source = genweb.organs  # No funciona
source = src/genweb.organs  # Solo si est√°s en la ra√≠z del buildout
```

#### Comandos de Coverage

```bash
# Desde el directorio del paquete (donde est√° .coveragerc)
cd src/my.package

# Ejecutar coverage con un test espec√≠fico
../../bin/coverage run --source=src/my/package ../../bin/test -s my.package -t test_votaciones

# Ejecutar coverage con todos los tests
../../bin/coverage run --source=src/my/package ../../bin/test -s my.package

# Generar reporte en texto
../../bin/coverage report --show-missing

# Generar reporte HTML
../../bin/coverage html -d coverage_report

# Abrir en navegador
open coverage_report/index.html
```

### Objetivo Coverage
- Unitarios: > 80%
- Integraci√≥n: > 70%
- Total: > 75%

## üêõ Debugging Tests

### IPython en Tests
```python
def test_debug_example(self):
    """Test con debugging"""
    content = self.create_content()

    # Insertar debugger
    import ipdb; ipdb.set_trace()

    # Continuar test
    self.assertEqual(content.title, 'Test Document')
```

### Ejecutar con pdb
```bash
# Debugger autom√°tico en errores
bin/test -s my.package -D

# Con ipdb si est√° instalado
bin/test -s my.package --ipdb
```

### Print Debugging
```python
def test_with_debug_output(self):
    """Test con output de debug"""
    content = self.create_content()

    # Ver estado
    print(f"Content: {content}")
    print(f"State: {api.content.get_state(content)}")

    self.assertEqual(content.portal_type, 'Document')
```

## üìã Checklist de Testing

### Antes de Commit
- [ ] Todos los tests pasan
- [ ] Coverage no baja
- [ ] No hay tests skipped sin raz√≥n
- [ ] Tests nuevos para nuevas features
- [ ] Tests de regresi√≥n para bugs
- [ ] Sin prints o debuggers olvidados

### Code Review
- [ ] Tests claros y descriptivos
- [ ] Cubren casos edge
- [ ] No hay l√≥gica compleja en tests
- [ ] Mocks justificados
- [ ] Fixtures reutilizables
- [ ] Documentaci√≥n en docstrings

### CI/CD
- [ ] Tests pasan en CI
- [ ] Coverage reportado
- [ ] No hay warnings
- [ ] Tests r√°pidos (< 5 min total)
- [ ] Sin dependencias externas

## üéØ Tipos de Tests por Feature

### Para Content Types
- Creaci√≥n
- Campos y schemas
- Indexaci√≥n en cat√°logo
- Permissions
- Workflow states

### Para Behaviors
- Aplicaci√≥n a tipos
- Campos del behavior
- Adaptaci√≥n correcta
- Interacci√≥n con otros behaviors

### Para Views
- Renderizado HTML
- Permissions de acceso
- Datos en contexto
- Formularios y POST

### Para Vocabularies
- Valores disponibles
- Filtrado correcto
- Performance con muchos items
- Internacionalizaci√≥n

### Para Upgrades
- Versi√≥n inicial y final
- Migraci√≥n de datos
- Sin errores en logs
- Rollback posible

### Para Workflows
- Estados definidos
- Transiciones v√°lidas
- Permissions por estado
- Guards funcionan

## üîÑ Testing de Migraci√≥n

### Ejemplo
```python
import unittest
from plone import api
from plone.app.testing import setRoles, TEST_USER_ID
from my.package.testing import MY_PACKAGE_INTEGRATION_TESTING


class TestMigration(unittest.TestCase):
    """Tests de migraci√≥n de datos"""

    layer = MY_PACKAGE_INTEGRATION_TESTING

    def setUp(self):
        """Configuraci√≥n inicial"""
        self.portal = self.layer['portal']
        setRoles(self.portal, TEST_USER_ID, ['Manager'])

    def test_upgrade_step(self):
        """Test paso de actualizaci√≥n"""
        from my.package.upgrades import upgrade_to_1001

        # Ejecutar upgrade
        upgrade_to_1001(self.portal)

        # Verificar cambios
        # ...

    def test_data_migration(self):
        """Test migraci√≥n de datos"""
        # Crear contenido con formato viejo
        content = api.content.create(
            container=self.portal,
            type='Document',
            id='doc1',
        )
        content.old_field = "old_value"

        # Ejecutar migraci√≥n
        from my.package.migration import migrate_data
        migrate_data(content)

        # Verificar formato nuevo
        self.assertTrue(hasattr(content, 'new_field'))
        self.assertEqual(content.new_field, "old_value")
```

## üåê Testing Internacionalizaci√≥n

### Ejemplo
```python
import unittest
from my.package.testing import MY_PACKAGE_INTEGRATION_TESTING


class TestI18N(unittest.TestCase):
    """Tests de internacionalizaci√≥n"""

    layer = MY_PACKAGE_INTEGRATION_TESTING

    def test_translations_exist(self):
        """Test que existen traducciones"""
        from zope.i18n import translate

        msgid = 'my_package_label'

        # Catal√°n
        translation_ca = translate(msgid, target_language='ca')
        self.assertNotEqual(translation_ca, msgid)

        # Espa√±ol
        translation_es = translate(msgid, target_language='es')
        self.assertNotEqual(translation_es, msgid)

        # Ingl√©s
        translation_en = translate(msgid, target_language='en')
        self.assertNotEqual(translation_en, msgid)
```

## üé® Testing de Templates

### Ejemplo
```python
import unittest
from plone import api
from plone.app.testing import setRoles, TEST_USER_ID
from my.package.testing import MY_PACKAGE_INTEGRATION_TESTING


class TestTemplates(unittest.TestCase):
    """Tests para templates"""

    layer = MY_PACKAGE_INTEGRATION_TESTING

    def setUp(self):
        """Configuraci√≥n inicial"""
        self.portal = self.layer['portal']
        self.request = self.layer['request']
        setRoles(self.portal, TEST_USER_ID, ['Manager'])

    def test_template_renders(self):
        """Test que template renderiza"""
        content = api.content.create(
            container=self.portal,
            type='Document',
            id='doc1',
        )

        view = content.restrictedTraverse('@@my_view')
        html = view()

        self.assertIn('<html', html)
        self.assertIn('</html>', html)

    def test_template_variables(self):
        """Test variables en template"""
        content = api.content.create(
            container=self.portal,
            type='Document',
            id='doc1',
            title='Test Title',
        )

        view = content.restrictedTraverse('@@my_view')
        html = view()

        self.assertIn('Test Title', html)
```

## üìù Documentaci√≥n de Tests Nuevos

### ‚ö†Ô∏è IMPORTANTE: Siempre que se cree un test nuevo, actualizar la documentaci√≥n

Cuando crees un test nuevo, **debes actualizar** estos archivos para mantener la documentaci√≥n sincronizada:

#### 1Ô∏è‚É£ **README_TESTS.md** (src/my.package/tests/README_TESTS.md)

**A√±adir entrada en la lista de tests:**

```markdown
X. **test_nuevo_nombre.py** ‚≠ê NUEVO
   - Descripci√≥n breve del test
   - Qu√© permisos/funcionalidad verifica
   - N√∫mero de tests implementados
```

**A√±adir comando de ejecuci√≥n:**

```markdown
#### Tests de [nombre descriptivo] ‚≠ê NUEVO
\```bash
./bin/test -s my.package -t test_nuevo_nombre
\```
```

**Actualizar resumen final:**

```markdown
**Total: X/X tests (100%)**
**Y tests funcionales en total**:
- ‚úÖ N tests - [Descripci√≥n del nuevo test]
```

#### 2Ô∏è‚É£ **tests_coverage.md** (src/my.package/docs/tests_coverage.md)

**A√±adir secci√≥n completa con tabla de permisos:**

```markdown
### X. [T√≠tulo del Test]
**Archivo**: `test_nuevo_nombre.py` ‚≠ê IMPLEMENTADO

**Cubre**:

| Acci√≥n/Permiso | Rol1 | Rol2 | Rol3 | ... |
|----------------|------|------|------|-----|
| **Acci√≥n 1** | ‚úÖ | ‚ùå | ‚úÖ | ... |
| **Acci√≥n 2** | ‚úÖ | ‚úÖ | ‚ùå | ... |

**Nota**: Explicaci√≥n adicional si es necesaria
```

**Actualizar resumen y comandos:**

```markdown
### ‚úÖ Implementados: X/X tests (100%)
**Total de tests funcionales implementados: Y tests**

# Tests individuales
./bin/test -s my.package -t test_nuevo_nombre    # N tests
```

#### 3Ô∏è‚É£ **resumen_permisos_[proyecto].html** (solo si aplica)

**Solo actualizar si el test verifica permisos nuevos o acciones no documentadas:**

```html
<h3>NUEVA SECCI√ìN</h3>
<table>
    <thead>
        <tr>
            <th>Acci√≥n/Permiso</th>
            <th>Rol1</th>
            <th>Rol2</th>
            <!-- ... m√°s roles ... -->
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><strong>Nueva acci√≥n</strong></td>
            <td class="check">‚úÖ</td>
            <td class="cross">‚ùå</td>
            <!-- ... -->
        </tr>
    </tbody>
</table>
```

**Actualizar el √≠ndice HTML:**

```html
<ul>
    <li><a href="#nueva-seccion">üÜï Nueva Secci√≥n</a></li>
</ul>
```

### üìã Checklist de Documentaci√≥n de Tests

Al crear un test nuevo, verificar:

- [ ] ‚úÖ **README_TESTS.md**: A√±adida entrada + comando + actualizado resumen
- [ ] ‚úÖ **tests_coverage.md**: A√±adida secci√≥n + tabla + actualizado resumen
- [ ] ‚úÖ **resumen_permisos_*.html**: Actualizado (solo si aplica)
- [ ] ‚úÖ **Prints informativos**: Test incluye prints con emojis (‚úÖ/‚ùå/‚úì)
- [ ] ‚úÖ **test_zzz_summary**: Test incluye resumen al final
- [ ] ‚úÖ **Docstring**: Descripci√≥n clara del test
- [ ] ‚úÖ **Total de tests**: Actualizado en TODOS los documentos

### üîÑ Workflow Recomendado

```bash
# 1. Crear el test
touch src/my/package/tests/test_nueva_funcionalidad.py

# 2. Implementar el test (ver plantilla abajo)

# 3. Ejecutar el test
./bin/test -s my.package -t test_nueva_funcionalidad

# 4. Actualizar documentaci√≥n (README_TESTS.md + tests_coverage.md)

# 5. Ejecutar todos los tests
./bin/test -s my.package

# 6. Verificar cobertura
cd src/my.package
../../bin/coverage run --source=src/my/package ../../bin/test -s my.package
../../bin/coverage html -d coverage_report

# 7. Commit
git add .
git commit -m "test: a√±adir tests para [funcionalidad]

- Implementados X tests para verificar [qu√©]
- Actualizada documentaci√≥n (README_TESTS.md, tests_coverage.md)"
```

### üìÑ Plantilla de Test con Documentaci√≥n

```python
"""Tests para [funcionalidad].

Este m√≥dulo verifica:
- Permiso A para Rol1, Rol2
- Permiso B para Rol3
- Restricci√≥n C para Rol4
"""

import unittest
import warnings
from AccessControl import Unauthorized
from plone import api
from plone.app.testing import (
    TEST_USER_ID,
    TEST_USER_NAME,
    login,
    logout,
    setRoles,
)

from my.package.testing import MY_PACKAGE_FUNCTIONAL_TESTING


class TestNuevaFuncionalidad(unittest.TestCase):
    """Tests funcionales para [descripci√≥n].

    Verifica los permisos de [acci√≥n] para los diferentes roles.
    """

    layer = MY_PACKAGE_FUNCTIONAL_TESTING

    def setUp(self):
        """Configuraci√≥n inicial del test."""
        # Suprimir warnings
        warnings.filterwarnings("ignore", category=ResourceWarning)
        warnings.filterwarnings("ignore", category=DeprecationWarning)

        # Referencias del layer
        self.portal = self.layer['portal']
        self.request = self.layer['request']

        # Setup de contenido
        # ...

        logout()

    def test_rol1_puede_accion(self):
        """Test que Rol1 puede realizar acci√≥n."""
        print("\n‚úÖ Verificando permisos del rol Rol1")

        logout()
        setRoles(self.portal, TEST_USER_ID, ['Rol1'])
        login(self.portal, TEST_USER_NAME)

        print("  ‚úì Verificando acceso a acci√≥n")
        self.assertTrue(...)
        print("  ‚úì Acceso correcto")

        print("  ‚úì Verificaci√≥n completa como Rol1")
        logout()

    def test_rol2_no_puede_accion(self):
        """Test que Rol2 NO puede realizar acci√≥n."""
        print("\n‚ùå Verificando restricciones del rol Rol2")

        logout()
        setRoles(self.portal, TEST_USER_ID, ['Rol2'])
        login(self.portal, TEST_USER_NAME)

        print("  ‚úì Verificando restricciones")
        with self.assertRaises(Unauthorized):
            ...
        print("  ‚úì Acceso denegado correctamente")

        print("  ‚úì Verificaci√≥n completa como Rol2")
        logout()

    def test_zzz_summary(self):
        """Resumen informativo de permisos verificados."""
        print("\n" + "=" * 70)
        print("üìä RESUMEN - Tests de [Funcionalidad]")
        print("=" * 70)

        print("\n‚úÖ Permisos verificados:")
        print("  - Rol1: PUEDE realizar acci√≥n")
        print("  - Rol2: NO puede realizar acci√≥n")

        print("\nüìã Total: X tests implementados")
        print("‚úÖ Estado: Todos los tests pasando")
        print("=" * 70)
```

## ‚úÖ Checklist antes de Commit

### Tests
- [ ] Todos los tests pasan localmente (`./bin/test -s my.package`)
- [ ] Coverage no ha bajado
- [ ] Sin `print()` ni `import ipdb; ipdb.set_trace()` olvidados (excepto prints informativos)
- [ ] Tests nuevos para nuevas features
- [ ] Tests de regresi√≥n para bugs corregidos

### C√≥digo
- [ ] Docstrings descriptivos en todos los tests
- [ ] Nombres de tests claros: `test_<accion>_<resultado_esperado>`
- [ ] Sin dependencias externas (APIs, servicios web)
- [ ] Tests independientes (sin orden de ejecuci√≥n requerido)
- [ ] Datos de test en fixtures o setUp (no hardcodeados)
- [ ] tearDown limpia correctamente

### **üìù Documentaci√≥n** (CR√çTICO)
- [ ] **‚úÖ README_TESTS.md actualizado** (entrada + comando + resumen)
- [ ] **‚úÖ tests_coverage.md actualizado** (secci√≥n + tabla + resumen)
- [ ] **‚úÖ resumen_permisos_*.html actualizado** (solo si aplica)
- [ ] **‚úÖ Total de tests actualizado** en todos los documentos
- [ ] **‚úÖ Prints informativos** con emojis en el test
- [ ] **‚úÖ test_zzz_summary** incluido al final

### Git
- [ ] Mensaje de commit convencional con descripci√≥n de documentaci√≥n actualizada

## üìä Objetivos de Coverage

| Categor√≠a | Objetivo | M√≠nimo Aceptable |
|-----------|----------|------------------|
| Tests Unitarios | > 80% | 70% |
| Tests Integraci√≥n | > 70% | 60% |
| **Coverage Total** | **> 75%** | **65%** |
| C√≥digo Cr√≠tico | 100% | 90% |

### Qu√© cubrir prioritariamente
1. üî¥ **Cr√≠tico** (100%): Permisos, seguridad, migraci√≥n de datos
2. üü† **Alto** (90%): Business logic, workflows, content types
3. üü° **Medio** (75%): Views, behaviors, vocabularies
4. üü¢ **Bajo** (50%): Templates, helpers, utilidades simples

## üîç Troubleshooting Tests

### Error: `ComponentLookupError`
**Causa**: Componente no registrado en ZCML

**Soluci√≥n**:
```python
# En testing.py
def setUpZope(self, app, configurationContext):
    self.loadZCML(package=my.package)
```

### Error: `Unauthorized`
**Causa**: Faltan roles o no hay login

**Soluci√≥n**:
```python
from plone.app.testing import setRoles, login, TEST_USER_ID, TEST_USER_NAME

# Opci√≥n 1: Dar roles
setRoles(self.portal, TEST_USER_ID, ['Manager'])

# Opci√≥n 2: Login expl√≠cito
login(self.portal, TEST_USER_NAME)
```

### Error: `AttributeError: 'NoneType' object has no attribute 'portal_type'`
**Causa**: `self.layer['portal']` no disponible o contenido no creado

**Soluci√≥n**:
```python
def setUp(self):
    self.portal = self.layer['portal']
    self.request = self.layer['request']
    # Verificar que existen
    self.assertIsNotNone(self.portal)
```

### Tests lentos
**Causas y soluciones**:
- Usar `INTEGRATION_TESTING` en lugar de `FUNCTIONAL_TESTING` cuando sea posible
- Evitar `api.content.create()` repetido ‚Üí crear fixtures en `setUp`
- Mock de servicios externos (email, APIs, filesystem)
- Evitar `time.sleep()` ‚Üí usar eventos o mocks

### Error: `ImportError` en tests
**Causa**: Dependencias no instaladas o ZCML no cargado

**Soluci√≥n**:
```python
# En testing.py, cargar dependencias
def setUpZope(self, app, configurationContext):
    import my.dependency
    self.loadZCML(package=my.dependency)
    self.loadZCML(package=my.package)
```

### Tests intermitentes (flaky)
**Causas comunes**:
- Tests que dependen del orden de ejecuci√≥n
- Estado compartido entre tests
- Uso de `datetime.now()` sin mock
- Race conditions

**Soluci√≥n**:
```python
# Mock de datetime
from unittest.mock import patch
from datetime import datetime

@patch('my.package.utils.datetime')
def test_with_fixed_datetime(self, mock_datetime):
    mock_datetime.now.return_value = datetime(2024, 1, 1, 12, 0, 0)
    # Test con fecha fija
```

### Error: `KeyError` en `self.layer['portal']`
**Causa**: Layer no inicializado correctamente

**Soluci√≥n**:
```python
# Verificar que la layer est√° definida
class TestMyFeature(unittest.TestCase):
    layer = MY_PACKAGE_INTEGRATION_TESTING  # ‚Üê Importante
```

## üí° Tips Avanzados

### Testing de RichText Fields
```python
from plone.app.textfield.value import RichTextValue

content = api.content.create(
    container=self.portal,
    type='Document',
    id='doc1',
    text=RichTextValue('<p>HTML content</p>', 'text/html', 'text/html')
)
```

### Testing de Acquisition
```python
# context.organType funciona por Acquisition
organ = api.content.create(type='Organ', organType='open_organ', ...)
session = api.content.create(container=organ, type='Session', ...)

# session.organType funciona por Acquisition ‚úÖ
self.assertEqual(session.organType, 'open_organ')
```

### Testing de Workflow con Transiciones
```python
# Aplicar transiciones en orden
from plone import api

session = api.content.create(...)
api.content.transition(obj=session, transition='convocar')
api.content.transition(obj=session, transition='realitzar')
api.content.transition(obj=session, transition='tancar')

state = api.content.get_state(session)
self.assertEqual(state, 'tancada')
```

### Suprimir Warnings en Tests
```python
import warnings

def setUp(self):
    # Suprimir ResourceWarnings de blobs
    warnings.filterwarnings("ignore", category=ResourceWarning)

    # Suprimir DeprecationWarnings de Plone
    warnings.filterwarnings("ignore", category=DeprecationWarning)
```
